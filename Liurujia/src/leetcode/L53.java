package leetcode;
/*
 * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

思路：
	这个题，我的思路就是非常原始的那个循环嵌套的做法，所以我放弃了。我学习了一个网上的方法
	叫“扫描法”，具体做法就是，如果当前数要比0小，那就说明，对最后的结果没有积极影响，不能
	累加，应该舍去，并且换成下一个数；否则那肯定就是一个正数了，说明对最后的结果有积极的
	影响，应该累加，跟下一个数累加；最后再判断这个记录结果的数是否是最大的，那当然需要一个
	变量来保存最大的数
	
	另外的解法动态规划，递归，我实在有些困难
	
	我是看的这篇博客
	https://blog.csdn.net/zwzsdy/article/details/80029796
 */
public class L53 {
    public int maxSubArray(int[] nums) {
        //用来记录中间结果,让它等于第一个，就是为了能够每次都能跟下一个做比较
    	//这样一来，下次循环只需要从1开始，这样跟它比较的是下一个，因此就可以
    	//来实现依次比较，当这个跟下一个数字的比较处理完毕后，current的变量值
    	//也相应的变了，因此就需要接受再下一个的数字来处理
    	int current = nums[0];
    	//这个用来记录最大的结果
    	int sum = nums[0];
    	for(int i = 1;i<nums.length;i++){
    		//如果当前的这个数字小于0，那就应该舍去，并且取下一个数字
    		if(current<0){
    			current = nums[i];
    		}else{//否则那肯定是大于0，那应该可以跟下一个数字相加
    			current += nums[i];
    		}
    		//记录最大的值
    		if(current>sum){
    			sum = current;
    		}
    	}
    	return sum;
    }
    
    public static void main(String[] args) {
		int[] nums = {-2,1,-3,4,-1,2,1,-5,4};
		System.out.println(new L53().maxSubArray(nums));
	}
}
